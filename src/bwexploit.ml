(* Copyright (C) 2019, Francois Berenger

   Yamanishi laboratory,
   Department of Bioscience and Bioinformatics,
   Faculty of Computer Science and Systems Engineering,
   Kyushu Institute of Technology,
   680-4 Kawazu, Iizuka, Fukuoka, 820-8502, Japan. *)

open Printf

module A = MyArray
module CLI = Minicli.CLI
module FpMol = Molenc.FpMol
module L = MyList
module Log = Dolog.Log
module ROC = Common.ROC
module SL = Common.SL
module Top = Cpm.TopKeeper

let compute_rate start_t count =
  (float count) /. (Unix.gettimeofday() -. start_t)

let read_some in_count db_in () =
  try
    begin
      let line = input_line db_in in
      let test_mol = Common.mol_of_line (!in_count, line) in
      incr in_count;
      test_mol
    end
  with End_of_file -> raise Parany.End_of_input

let process_some
    acts_bst platt_proba kernel n_acts n_decs bwidth mols_bst test_mol =
  let in_AD =
    (not !Flags.use_AD) ||
    let _nearest_act, nearest_d =
      Bstree.nearest_neighbor test_mol acts_bst in
    nearest_d < bwidth in
  let name = FpMol.get_name test_mol in
  if in_AD then
    let act_contrib, dec_contrib = 
      Common.score_one_single_raw
        kernel n_acts n_decs bwidth mols_bst test_mol in
    let score = Utls.score_mol act_contrib dec_contrib in
    let platt_p = platt_proba score in
    let kde_p = act_contrib /. (act_contrib +. dec_contrib) in
    (name, score, platt_p, kde_p)
  else
    (* we use the AD to score DB faster: out of AD =>
       we don't even score this candidate molecule
       we use -1.0 as a dumb raw score
       and -.0.0 as a probability meaning "out of AD" *)
    (name, -1.0, -0.0, -0.0)

(* CRITICAL: since the top scores and corresponding molecule names
   are long-lived in memory, we need Parany.set_copy_on_mux *)
let gather_some
    out_count start_t top_K scores_out (name, score, platt_p, kde_p) =
  begin match top_K with
    | Some top ->
      (* in case of TopK, values will be long lived in memory so
            we have to copy them out of the shm *)
      Top.add top score (name, platt_p, kde_p)
    | None ->
      begin
        if !out_count = 0 then
          fprintf scores_out "#name raw-score Platt-p KDE-p\n";
        fprintf scores_out "%s %f %.3f %.3f\n"
          name score platt_p kde_p
      end
  end;
  incr out_count;
  if (!out_count mod 2000) = 0 then
    let rate = compute_rate start_t !out_count in
    printf "done: %d @ %.1f mo./s\r%!" !out_count rate

let main () =
  Log.color_on ();
  Log.set_log_level Log.INFO;
  Log.info "start";
  let argc, args = CLI.init () in
  let show_help = CLI.get_set_bool ["-h";"--help"] args in
  if argc = 1 || show_help then
    (eprintf "usage:\n  \
              %s -i <train.txt> -db <test.{txt|bin}>\n  \
              -k {uni|tri|epa|biw}: kernel function choice (default=biw)\n  \
              -np <int>: max number of processes (default=1)\n  \
              -c <int>: parallelization chunk size (default=1)\n  \
              -o <filename>: raw scores output file\n  \
              -kb <float>]: kernel bandwidth\n  \
              -a <float>: Platt scaling A parameter\n  \
              -b <float>: Platt scaling B parameter\n  \
              [--proba]: use KDE probability to score molecules\n  \
              (default=KDE difference)\n  \
              [--pin-cores] enable core-pinning \
              (to accelerate parallel jobs)\n  \
              [--capf <float>:] keep only fraction of decoys\n  \
              [--capi <int>:] keep only N molecules in total\n  \
              [--capx <int>:] keep only N decoys per active\n  \
              [--seed <int>: fix random seed]\n  \
              [-t <int>]: only keep N top scoring molecules\n  \
              [-h|--help]: show this help message\n  \
              [-v]: verbose/debug mode\n  \
              [--no-AD]: disable AD (slower)\n"
       Sys.argv.(0);
     exit 1);
  let input_fn = CLI.get_string ["-i"] args in
  let cap =
    Common.get_cap
      (CLI.get_float_opt ["--capf"] args)
      (CLI.get_int_opt ["--capi"] args)
      (CLI.get_int_opt ["--capx"] args) in
  let scores_fn = CLI.get_string ["-o"] args in
  let db_fn = CLI.get_string ["-db"] args in
  let k_str = CLI.get_string_def ["-k"] args "biw" in
  let kernel = Kernel.of_string k_str in
  let bwidth = CLI.get_float ["-kb"] args in
  let top_n = CLI.get_int_def ["-t"] args 0 in
  let a = CLI.get_float ["-a"] args in
  let b = CLI.get_float ["-b"] args in
  let nprocs = CLI.get_int_def ["-np"] args 1 in
  let csize = CLI.get_int_def ["-c"] args 1 in
  let verbose = CLI.get_set_bool ["-v"] args in
  let pin_cores = CLI.get_set_bool ["--pin-cores"] args in
  Flags.use_AD := CLI.get_reset_bool ["--no-AD"] args;
  if CLI.get_set_bool ["--proba"] args then
    Flags.score_fun := Probability;
  let rng = match CLI.get_int_opt ["--seed"] args with
    | None -> BatRandom.State.make_self_init ()
    | Some seed -> BatRandom.State.make [|seed|] in
  CLI.finalize (); (* ----------------------------------------------------- *)
  let platt_proba = ROC.platt_probability a b in
  (* model production use *)
  let n_acts, n_decs, train_mols =
    let train =
      let numbered_lines =
        L.numerate 0 (Utls.uncommented_lines_of_file "#" input_fn) in
      Common.maybe_cap rng cap numbered_lines in
    let mols = L.map Common.mol_of_line train in
    let n_acts, n_decs = L.filter_counts FpMol.is_active mols in
    (n_acts, n_decs, A.of_list mols) in
  let mols_bst = Bstree.(create 1 Two_bands train_mols) in
  let top_K =
    if top_n <= 0 then None
    else
      Some (Top.create top_n) in
  let acts_bst =
    Bstree.(create 1 Two_bands
              (A.filter FpMol.is_active train_mols)) in
  Utls.with_out_file scores_fn (fun scores_out ->
      Utls.with_in_file db_fn (fun db_in ->
          let in_count = ref 0 in
          let out_count = ref 0 in
          let start_t = Unix.gettimeofday () in
          (if pin_cores then Parany.enable_core_pinning ());
          Parany.run ~verbose ~csize ~nprocs
            ~demux:(read_some in_count db_in)
            ~work:(process_some acts_bst platt_proba
                     kernel n_acts n_decs bwidth mols_bst)
            ~mux:(gather_some out_count start_t top_K scores_out);
          let overall_rate = compute_rate start_t !out_count in
          printf "total: %d @ %.1f mo./s\n%!" !out_count overall_rate;
          match top_K with
          | None -> ()
          | Some top ->
            let top_scores = Top.high_scores_first top in
            fprintf scores_out "#name raw-score Platt-p KDE-p\n";
            L.iter (fun (score, (name, platt_p, kde_p)) ->
                fprintf scores_out "%s %f %.3f %.3f\n"
                  name score platt_p kde_p
              ) top_scores
        )
    )

let () = main ()
